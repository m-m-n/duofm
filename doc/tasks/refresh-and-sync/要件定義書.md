# 機能: 画面更新とペイン同期

## 概要

duofmに以下の2つの機能を追加します：

1. **画面更新機能（F5/Ctrl+R）**: ファイルシステムの変更を反映するため、両方のペインを再読み込み
2. **ペイン同期機能（=）**: アクティブペインのディレクトリを反対側のペインに適用

これらの機能により、外部でのファイル変更の確認や、両方のペインで同じディレクトリを異なる設定（隠しファイル表示など）で表示することが可能になります。

## 目的

- ファイルシステムの変更を即座に反映できるようにする
- 同じディレクトリを両方のペインで表示し、ファイル操作を効率化する
- 異なる表示設定（隠しファイルの表示/非表示）で同じディレクトリを比較できるようにする

## ユーザーストーリー

### US-1: 画面更新
**ユーザーとして、** 外部プログラムがファイルを追加・削除・変更した後、
**F5またはCtrl+Rを押すことで** 表示を最新の状態に更新できるようにしたい。
**なぜなら、** 別のターミナルやプログラムでファイル操作を行った際に、その変更をすぐに確認したいから。

### US-2: ペイン同期
**ユーザーとして、** =キーを押すことで、
**反対側のペインを現在のペインと同じディレクトリに変更したい。**
**なぜなら、** 同じディレクトリ内でファイルを選択したり、異なる表示設定で比較したりしたいから。

## 技術要件

### 要件1: 画面更新機能（F5/Ctrl+R）

#### キーバインディング

| キー | 動作 |
|------|------|
| `F5` | 両方のペインを再読み込み |
| `Ctrl+R` | 両方のペインを再読み込み（F5と同じ） |

#### 動作仕様

1. **更新の範囲**
   - 左右両方のペインを同時に更新
   - アクティブペインに関わらず両方を更新

2. **カーソル位置の保持**
   - 各ペインで現在選択されているファイル名を記憶
   - 再読み込み後、同じファイル名があればそのファイルを選択
   - ファイルが存在しない場合は、以前のカーソル位置（インデックス）を維持
   - インデックスが範囲外の場合は最後のエントリを選択

3. **更新内容**
   - ディレクトリの内容を再読み込み（ファイル/ディレクトリの追加・削除・変更を反映）
   - ディスク空き容量を再計算

4. **エラーハンドリング**
   - 表示中のディレクトリが削除されていた場合：
     - 存在する親ディレクトリまで遡る
     - ルートディレクトリまで遡っても存在しない場合は、ホームディレクトリに移動
     - ホームディレクトリも存在しない場合は、ルート（/）に移動
   - ディレクトリの読み込み権限がなくなっていた場合：
     - エラーダイアログを表示
     - ペインは以前の状態を維持

5. **視覚的フィードバック**
   - 特別なインジケーターやメッセージは不要
   - 処理は通常瞬時に完了するため

### 要件2: ペイン同期機能（=）

#### キーバインディング

| キー | 動作 |
|------|------|
| `=` | 反対側のペインをアクティブペインと同じディレクトリに変更 |

#### 動作仕様

1. **基本動作**
   - アクティブペインの現在のディレクトリパスを取得
   - 反対側のペインを同じディレクトリに変更

2. **カーソル位置**
   - 反対側のペインのカーソルは先頭（インデックス0）に移動
   - スクロールオフセットも0にリセット

3. **同じディレクトリの場合**
   - 既に両方のペインが同じディレクトリを表示している場合は何もしない
   - 無言で処理をスキップ（エラーメッセージなどは表示しない）

4. **表示設定の維持**
   - 反対側のペインの隠しファイル表示設定（`showHidden`）は維持
   - 反対側のペインの表示モード（`displayMode`）は維持
   - これにより、同じディレクトリを異なる設定で表示可能

5. **履歴の更新**
   - 反対側のペインの「前のディレクトリ」（`previousPath`）を更新
   - これにより、`-`キーで元のディレクトリに戻れる

## 実装アプローチ

### アーキテクチャ

```
internal/ui/
├── keys.go          # 新しいキー定義を追加
├── pane.go          # Refresh(), SyncTo()メソッドを追加
├── pane_test.go     # テストを追加
├── model.go         # キーハンドラーを追加
└── model_test.go    # テストを追加
```

### データ構造

既存の構造体を使用。新しいフィールドの追加は不要。

### キー定義（keys.go）

```go
const (
    // ... 既存のキー定義
    KeyRefresh   = "f5"      // 画面更新
    KeyRefreshAlt = "ctrl+r" // 画面更新（代替）
    KeySyncPane  = "="       // ペイン同期
)
```

### Paneメソッド（pane.go）

#### Refresh() - ペインを再読み込み

```go
// Refresh reloads the current directory, preserving cursor position
func (p *Pane) Refresh() error {
    // 現在選択されているファイル名を保存
    var selectedName string
    if p.cursor < len(p.entries) {
        selectedName = p.entries[p.cursor].Name
    }
    savedCursor := p.cursor

    // ディレクトリを再読み込み（存在チェック付き）
    currentPath := p.currentPath
    for {
        if fs.DirectoryExists(currentPath) {
            break
        }
        // 親ディレクトリに遡る
        parent := filepath.Dir(currentPath)
        if parent == currentPath {
            // ルートに到達したが存在しない場合
            home, err := fs.HomeDirectory()
            if err == nil && fs.DirectoryExists(home) {
                currentPath = home
                break
            }
            currentPath = "/"
            break
        }
        currentPath = parent
    }

    if currentPath != p.currentPath {
        // ディレクトリが変更された場合
        p.currentPath = currentPath
    }

    err := p.LoadDirectory()
    if err != nil {
        return err
    }

    // カーソル位置を復元
    if selectedName != "" {
        // 同じ名前のファイルを探す
        for i, e := range p.entries {
            if e.Name == selectedName {
                p.cursor = i
                p.ensureCursorVisible()
                return nil
            }
        }
    }

    // ファイルが見つからない場合、以前のインデックスを使用
    if savedCursor < len(p.entries) {
        p.cursor = savedCursor
    } else if len(p.entries) > 0 {
        p.cursor = len(p.entries) - 1
    } else {
        p.cursor = 0
    }
    p.ensureCursorVisible()

    return nil
}
```

#### SyncTo() - 指定されたディレクトリに同期

```go
// SyncTo synchronizes this pane to the specified directory
// Preserves display settings but resets cursor to top
func (p *Pane) SyncTo(path string) error {
    // 既に同じディレクトリの場合は何もしない
    if p.currentPath == path {
        return nil
    }

    // previousPathを更新
    p.previousPath = p.currentPath

    // ディレクトリを変更
    p.currentPath = path
    err := p.LoadDirectory()
    if err != nil {
        return err
    }

    // カーソルとスクロールを先頭にリセット
    p.cursor = 0
    p.scrollOffset = 0

    return nil
}
```

### Modelメソッド（model.go）

#### RefreshBothPanes() - 両方のペインを更新

```go
// RefreshBothPanes refreshes both panes
func (m *Model) RefreshBothPanes() tea.Cmd {
    var cmds []tea.Cmd

    // 左ペインを更新
    if err := m.leftPane.Refresh(); err != nil {
        m.dialog = NewErrorDialog(fmt.Sprintf("Failed to refresh left pane: %v", err))
    }

    // 右ペインを更新
    if err := m.rightPane.Refresh(); err != nil {
        m.dialog = NewErrorDialog(fmt.Sprintf("Failed to refresh right pane: %v", err))
    }

    // ディスク容量を更新
    m.updateDiskSpace()

    return tea.Batch(cmds...)
}
```

#### SyncOppositePane() - 反対側のペインを同期

```go
// SyncOppositePane synchronizes the opposite pane to the active pane's directory
func (m *Model) SyncOppositePane() {
    activePane := m.getActivePane()
    oppositePane := m.getOppositePane()

    if err := oppositePane.SyncTo(activePane.currentPath); err != nil {
        m.dialog = NewErrorDialog(fmt.Sprintf("Failed to sync pane: %v", err))
    }
}
```

#### Updateメソッドへの統合

```go
// In Update() method
case tea.KeyMsg:
    switch msg.String() {
    case KeyRefresh, KeyRefreshAlt:
        return m, m.RefreshBothPanes()

    case KeySyncPane:
        m.SyncOppositePane()
        return m, nil

    // ... 既存のケース
    }
```

## テストシナリオ

### 画面更新機能のテスト

#### 基本動作
- [ ] F5キーで両方のペインが再読み込みされる
- [ ] Ctrl+Rキーで両方のペインが再読み込みされる
- [ ] 再読み込み後、各ペインで同じファイルが選択されている（ファイル名が存在する場合）
- [ ] ファイルが削除されていた場合、以前のインデックスが維持される
- [ ] ディスク空き容量が再計算される

#### カーソル位置の保持
- [ ] 選択されていたファイルが存在する場合、同じファイルが選択される
- [ ] 選択されていたファイルが削除された場合、同じインデックスが維持される
- [ ] インデックスが範囲外の場合、最後のエントリが選択される
- [ ] エントリが空の場合、カーソルは0になる

#### エラーハンドリング
- [ ] ディレクトリが削除されていた場合、親ディレクトリに移動する
- [ ] ルートまで遡っても存在しない場合、ホームディレクトリに移動する
- [ ] ホームディレクトリも存在しない場合、ルート（/）に移動する
- [ ] 読み込み権限がない場合、エラーダイアログが表示される

#### ファイルシステムの変更反映
- [ ] 外部で追加されたファイルが表示される
- [ ] 外部で削除されたファイルが非表示になる
- [ ] 外部で名前変更されたファイルが正しく反映される
- [ ] ファイルサイズの変更が反映される
- [ ] ファイルの更新日時の変更が反映される

### ペイン同期機能のテスト

#### 基本動作
- [ ] =キーで反対側のペインがアクティブペインと同じディレクトリに変更される
- [ ] 左ペインがアクティブな場合、右ペインが同期される
- [ ] 右ペインがアクティブな場合、左ペインが同期される
- [ ] 同期後、反対側のペインのカーソルが先頭（0）になる
- [ ] 同期後、反対側のペインのスクロールオフセットが0になる

#### 表示設定の維持
- [ ] 反対側のペインの隠しファイル表示設定（showHidden）が維持される
- [ ] 反対側のペインの表示モード（displayMode）が維持される
- [ ] 左ペインが隠しファイル表示、右ペインが非表示の状態で同期しても設定は変わらない

#### 履歴の更新
- [ ] 同期後、反対側のペインのpreviousPathが正しく更新される
- [ ] 同期後、-キーで元のディレクトリに戻れる

#### エッジケース
- [ ] 両方のペインが既に同じディレクトリの場合、何もしない（エラーなし）
- [ ] 同期先のディレクトリが読み込めない場合、エラーダイアログが表示される
- [ ] 同期先のディレクトリが存在しない場合、エラーダイアログが表示される

### 統合テスト

- [ ] 画面更新とペイン同期を連続して実行しても正常に動作する
- [ ] 検索モード中にF5を押しても正常に動作する
- [ ] ダイアログ表示中はキーが無視される
- [ ] 既存のキーバインディングと競合しない

## 成功基準

- [ ] F5とCtrl+Rで両方のペインが正しく更新される
- [ ] カーソル位置が適切に保持される
- [ ] ディレクトリ削除時に適切な親ディレクトリに遡る
- [ ] =キーで反対側のペインが正しく同期される
- [ ] 同期時に表示設定が維持される
- [ ] 同じディレクトリの場合は無視される
- [ ] 既存の機能に影響を与えない
- [ ] すべてのユニットテストが合格する
- [ ] パフォーマンスが許容範囲内（更新処理 < 100ms）

## 依存関係

- 既存の`fs.DirectoryExists()`関数（存在しない場合は実装が必要）
- 既存の`fs.HomeDirectory()`関数
- Bubble Teaフレームワーク
- 新しい外部ライブラリは不要

## 未解決の質問

なし - すべての要件が明確化されています。

## スコープ外

以下の機能は今回の実装には含まれません：

- 自動更新（ファイルシステムウォッチャー）
- 更新頻度の設定
- 選択的な更新（片方のペインのみ）
- 更新履歴の保存
- 複数ディレクトリの同期
